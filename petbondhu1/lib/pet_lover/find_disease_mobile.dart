// find_disease_mobile.dart
import 'dart:io';
import 'dart:typed_data';
import 'dart:convert';
import 'dart:math' as math;

import 'package:flutter/material.dart';
import 'package:image_picker/image_picker.dart';
import 'package:flutter/services.dart' show rootBundle;
import 'package:tflite_flutter/tflite_flutter.dart';
// removed tflite_flutter_helper to avoid Android plugin namespace issues; using manual preprocessing
import 'package:image/image.dart' as img;
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_core/firebase_core.dart';

class FindDiseasePage extends StatefulWidget {
  const FindDiseasePage({Key? key}) : super(key: key);

  @override
  State<FindDiseasePage> createState() => _FindDiseasePageState();
}

class _FindDiseasePageState extends State<FindDiseasePage> {
  // Use the full asset key that appears in AssetManifest (assets/...) so the
  // interpreter can find the model at runtime.
  static const String MODEL_ASSET_NAME = 'assets/final_model_100epoch.tflite';
  static const String LABELS_ASSET = 'assets/labels.txt';

  Interpreter? _interpreter;
  List<String> _labels = [];
  bool _modelLoaded = false;
  bool _isProcessing = false;

  int _inputHeight = 224;
  int _inputWidth = 224;
  TensorType _inputType = TensorType.float32;

  XFile? _pickedImage;
  String? _prediction;
  String? _debugInfo;

  final ImagePicker _picker = ImagePicker();

  @override
  void initState() {
    super.initState();
    _initializeFirebaseAndModel();
  }

  Future<void> _initializeFirebaseAndModel() async {
    await Firebase.initializeApp();
    await _loadModelAndLabels();
  }

  @override
  void dispose() {
    _interpreter?.close();
    super.dispose();
  }

  Future<void> _loadModelAndLabels() async {
    try {
      _interpreter = await Interpreter.fromAsset(MODEL_ASSET_NAME);

      // Load labels file (may be empty). We'll fallback to autogenerated
      // labels later if the file is empty or missing.
      String labelsRaw = '';
      try {
        labelsRaw = await rootBundle.loadString(LABELS_ASSET);
      } catch (e) {
        debugPrint('Labels asset not found or empty: $e');
      }
      _labels = labelsRaw
          .split('\n')
          .map((s) => s.trim())
          .where((s) => s.isNotEmpty)
          .toList();

      final inputTensor = _interpreter!.getInputTensor(0);
      final shape = inputTensor.shape;
      if (shape.length >= 4) {
        _inputHeight = shape[1];
        _inputWidth = shape[2];
      }
  _inputType = inputTensor.type;

      setState(() {
        _modelLoaded = true;
      });
    } catch (e) {
      debugPrint('Error while creating interpreter: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Model load failed: $e')),
        );
      }
    }
  }

  Future<void> _pickImage(ImageSource source) async {
    try {
      final picked = await _picker.pickImage(source: source, imageQuality: 90);
      if (picked == null) return;
      setState(() {
        _pickedImage = picked;
        _prediction = null;
      });

      final bytes = await picked.readAsBytes();
      await _runInferenceFromBytes(bytes);
      await _uploadImageBase64(bytes);
    } catch (e) {
      debugPrint('Image pick error: $e');
    }
  }

  Future<void> _uploadImageBase64(Uint8List imageBytes) async {
    if (_prediction == null) return;
    try {
      String base64Image = base64Encode(imageBytes);

      // _prediction may contain multiple lines like "Label: 12.34%" per line.
      // Extract the first label name robustly (before ':' or '—').
      String firstLine = _prediction!.split('\n').first.trim();
      String diseaseName;
      if (firstLine.contains(':')) {
        diseaseName = firstLine.split(':').first.trim();
      } else if (firstLine.contains('—')) {
        diseaseName = firstLine.split('—').first.trim();
      } else {
        diseaseName = firstLine;
      }

      await FirebaseFirestore.instance.collection('disease').add({
        'image': base64Image,
        'disease': diseaseName,
        'debug': _debugInfo ?? '',
        'timestamp': FieldValue.serverTimestamp(),
      });

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Image and result saved: $diseaseName')),
        );
      }
    } catch (e) {
      debugPrint('Firestore upload error: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Upload failed: $e')),
        );
      }
    }
  }

  Future<void> _runInferenceFromBytes(Uint8List bytes) async {
    if (!_modelLoaded || _interpreter == null) return;
    setState(() => _isProcessing = true);

    try {
      debugPrint('Decoding image bytes, length=${bytes.length}');
      final libImage = img.decodeImage(bytes);
      if (libImage == null) throw 'Failed to decode image bytes';
      debugPrint('Decoded image: ${libImage.width}x${libImage.height}');

      final inputShape = _interpreter!.getInputTensor(0).shape; // [1,h,w,c]
      final outShape = _interpreter!.getOutputTensor(0).shape; // [1,n]
      final int inH = inputShape.length >= 3 ? inputShape[1] : _inputHeight;
      final int inW = inputShape.length >= 4 ? inputShape[2] : _inputWidth;
  // final int inC = inputShape.length == 4 ? inputShape[3] : 3; // unused

      final List<Map<String, double>> results = [];

      Future<Map<String, double>> runVariant(String variant) async {
        final resized = img.copyResize(libImage, width: inW, height: inH, interpolation: img.Interpolation.linear);

  // build input as nested lists
  if (_inputType == TensorType.uint8) {
          final input = List.generate(1, (_) => List.generate(inH, (y) => List.generate(inW, (x) {
                final p = resized.getPixel(x, y);
                final r = img.getRed(p);
                final g = img.getGreen(p);
                final b = img.getBlue(p);
                return List<int>.from([r, g, b]);
              })));

          int outLen = 1;
          for (final d in outShape.skip(1)) outLen *= d;
          final output = List.filled(outLen, 0.0);
          _interpreter!.run(input, output);

          List<double> rawList = output.map((e) => (e as num).toDouble()).toList();
          final probs = _applySoftmaxIfNeeded(rawList);

          List<String> labels = _labels;
          if (labels.isEmpty) labels = List.generate(probs.length, (i) => 'Label_$i');
          if (labels.length != probs.length) labels = List.generate(probs.length, (i) => i < _labels.length ? _labels[i] : 'Label_$i');

          final map = <String, double>{};
          for (var i = 0; i < probs.length; i++) map[labels[i]] = probs[i];
          return map;
        } else {
          // float input
          final input = List.generate(1, (_) => List.generate(inH, (y) => List.generate(inW, (x) {
                final p = resized.getPixel(x, y);
                final r = img.getRed(p);
                final g = img.getGreen(p);
                final b = img.getBlue(p);
                if (variant == '0-1') return [r / 255.0, g / 255.0, b / 255.0];
                if (variant == '-1-1') return [(r / 127.5) - 1.0, (g / 127.5) - 1.0, (b / 127.5) - 1.0];
                return [r / 255.0, g / 255.0, b / 255.0];
              })));

          int outLen = 1;
          for (final d in outShape.skip(1)) outLen *= d;
          final output = List.filled(outLen, 0.0);
          _interpreter!.run(input, output);

          List<double> rawList = output.map((e) => (e as num).toDouble()).toList();
          final probs = _applySoftmaxIfNeeded(rawList);

          List<String> labels = _labels;
          if (labels.isEmpty) labels = List.generate(probs.length, (i) => 'Label_$i');
          if (labels.length != probs.length) labels = List.generate(probs.length, (i) => i < _labels.length ? _labels[i] : 'Label_$i');

          final map = <String, double>{};
          for (var i = 0; i < probs.length; i++) map[labels[i]] = probs[i];
          return map;
        }
      }

      try {
        results.add(await runVariant('0-1'));
      } catch (e) {
        debugPrint('Variant 0-1 failed: $e');
      }
      try {
        results.add(await runVariant('-1-1'));
      } catch (e) {
        debugPrint('Variant -1-1 failed: $e');
      }
  if (_inputType == TensorType.uint8) {
        try {
          results.add(await runVariant('uint8'));
        } catch (e) {
          debugPrint('Variant uint8 failed: $e');
        }
      }

      if (results.isEmpty) throw 'No inference results (all variants failed)';

      results.sort((a, b) {
        double ma = a.values.isEmpty ? 0.0 : a.values.reduce((v, e) => v > e ? v : e);
        double mb = b.values.isEmpty ? 0.0 : b.values.reduce((v, e) => v > e ? v : e);
        return mb.compareTo(ma);
      });

      final Map<String, double> probMap = results.first;

      // Debug: print shapes and label counts to help troubleshoot
      try {
        final inShape = _interpreter!.getInputTensor(0).shape;
        debugPrint('TFLite input shape: $inShape');
      } catch (_) {}
      try {
        final outShape = _interpreter!.getOutputTensor(0).shape;
        debugPrint('TFLite output shape: $outShape');
      } catch (_) {}
      debugPrint('Labels count: ${_labels.length}');
      debugPrint('Raw probs: $probMap');

      final sorted = probMap.entries.toList()..sort((a, b) => b.value.compareTo(a.value));

      final debugParts = sorted.map((e) => '${e.key}:${(e.value).toStringAsFixed(6)}').toList();
      setState(() {
        if (sorted.isNotEmpty) {
          // show top-3 predictions for clarity
          final topN = sorted.take(3).map((e) => '${e.key}: ${(e.value * 100).toStringAsFixed(2)}%').toList();
          _prediction = topN.join('\n');
          _debugInfo = debugParts.join(', ');
        } else {
          _prediction = 'No result';
          _debugInfo = debugParts.join(', ');
        }
      });
    } catch (e) {
      debugPrint('Inference error (bytes): $e');
      setState(() => _prediction = 'Error while running model');
    } finally {
      setState(() => _isProcessing = false);
    }
  }

  // If the outputs are not normalized probabilities, apply softmax so they're
  // comparable across variants. If already sum ~1, return as-is.
  List<double> _applySoftmaxIfNeeded(List<double> raw) {
    if (raw.isEmpty) return raw;
    final sum = raw.fold<double>(0.0, (p, e) => p + e);
    if ((sum - 1.0).abs() < 1e-3 && raw.every((v) => v >= 0.0)) return raw;
    // apply softmax
    final max = raw.reduce((a, b) => a > b ? a : b);
    final exps = raw.map((v) => math.exp(v - max)).toList();
    final expsSum = exps.fold<double>(0.0, (p, e) => p + e);
    return exps.map((e) => e / expsSum).toList();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: Colors.deepPurple,
        title: const Text('Find Disease'),
      ),
      body: !_modelLoaded
          ? const Center(child: CircularProgressIndicator())
          : Padding(
              padding: const EdgeInsets.all(12.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Expanded(
                    child: Container(
                      decoration: BoxDecoration(
                        border: Border.all(color: Colors.grey.shade300),
                        borderRadius: BorderRadius.circular(8),
                      ),
                      child: _pickedImage == null
                          ? const Center(child: Text('No image selected'))
                          : Image.file(File(_pickedImage!.path), fit: BoxFit.contain),
                    ),
                  ),
                  const SizedBox(height: 12),
                  if (_isProcessing) ...[
                    const LinearProgressIndicator(),
                    const SizedBox(height: 8),
                  ],
                  Text(
                    _prediction ?? 'Press camera/gallery to check disease',
                    textAlign: TextAlign.center,
                    style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w600),
                  ),
                  const SizedBox(height: 8),
                  if (_debugInfo != null) ...[
                    Text(
                      'Debug: $_debugInfo',
                      textAlign: TextAlign.center,
                      style: const TextStyle(fontSize: 12, color: Colors.grey),
                    ),
                    const SizedBox(height: 8),
                  ],
                  const SizedBox(height: 12),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.spaceAround,
                    children: [
                      ElevatedButton.icon(
                        icon: const Icon(Icons.photo_library),
                        label: const Text('Gallery'),
                        onPressed: () => _pickImage(ImageSource.gallery),
                        style: ElevatedButton.styleFrom(backgroundColor: Colors.deepPurple),
                      ),
                      ElevatedButton.icon(
                        icon: const Icon(Icons.camera_alt),
                        label: const Text('Camera'),
                        onPressed: () => _pickImage(ImageSource.camera),
                        style: ElevatedButton.styleFrom(backgroundColor: Colors.deepPurple),
                      ),
                    ],
                  ),
                  const SizedBox(height: 8),
                ],
              ),
            ),
    );
  }
}
